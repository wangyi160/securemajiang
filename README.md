
安全麻将协议：

在麻将赌博中，我们最担心的是麻将牌的生成被操控，这样导致了结果也被操控，因此本协议以二人麻将的随机牌生成算法为基础，设计了安全麻将协议。
经过修改，也可以扩展到四人麻将的场景。


背景描述：

1. 游戏由两方组成，记为A，B
2. 密码算法采用AES。


牌生成协议

场景： A,B双方需要144张随机牌
要求： A和B共同打乱牌序

1. A将[1,2,...,144]进行随机洗牌，生成[a1,a2,...,a144]。
2. A生成144个密钥[sa1,sa2,...,sa144], 并将[a1,a2,...,a144] = > [enc(sa1, a1),..., enc(sa144, a144)]
3. A将[enc(sa1, a1),..., enc(sa144, a144)]发送给B
4. B将[enc(sa1, a1),..., enc(sa144, a144)]进行随机洗牌，生成[b1,b2,...,b144]
5. B生成144个密钥[sb1,sb2,...,sb144], 并将[b1,b2,...,b144] = > [enc(sb1, b1),..., enc(sb144, b144)]
6. B将[enc(sb1, b1),..., enc(sb144, b144)]发送给A

抓牌协议：

场景： A需要抓牌
要求： A抓牌时，B不知其内容

1. A生成随机数r，发送给B，表明准备抓加密数组中的第r个牌
2. 如果B中已经标记该位置已使用，返回错误给A，重新执行1
2. B发送sbr给A
3. A使用sbr和sar2（遍历）解密加密数组中的第r个元素enc(sbr, enc(sar2, ar2)), 得到ar2
4. B将加密数组中的r位置标记为已使用

场景： B需要抓牌
要求： B抓牌时，A不知其内容

注意： B不能简单的发送随机数r给A，因为A会根据r值知道B解密的是哪一个。

1. 利用oblivious transfer，B生成一个随机数r2，要A发送第r2个密钥，然而A并不知道r2为多少.
2. B使用sbr和sar2解密加密数组中的第r个元素enc(sbr, enc(sar2, ar2)), 得到ar2
3. B将加密数组中的r位置标记为已使用


出牌协议：

场景： A出牌
要求： B验证A是否出牌正确

1. A暴露(r, ar2, sar2)
2. B根据sbr和sar2解密enc(sbr, enc(sar2, ar2))，得到ar2'， 验证ar2'==ar2

场景： B出牌
要求： A验证B是否出牌正确

1. B暴露(r, ar2, sbr)
2. A根据sbr和sar2解密enc(sbr, enc(sar2, ar2)，得到ar2'， 验证ar2'==ar2

总结：

整个协议的难点和核心是oblivious transfer，是限制效率的部分，这部分是否还有更好的设计？





